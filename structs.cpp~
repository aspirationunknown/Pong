/***************************************************************************//**
 * structs.cpp
 * Authors - Derek Stotz, Charles Parsons
 *
 * This file contains functionality for the structures in the pong game.
 ******************************************************************************/
#include "structs.h"
 

 /***************************************************************************//**
 * applyCollision
 * Authors - Derek Stotz, Charles Parsons
 *
 * Takes a ball and a paddle and applies a velocity modification based on
    whether or not the paddle is in contact with the ball.
 ******************************************************************************/
void applyCollision(Ball &ball, Paddle paddle[2])
{
    //determine if ball and paddle collide, assuming (0,0) is in upper
    //left-hand corner of window

    //use ball position(center) and diameter, paddle position(upper left-hand 
    //corner) and dimensions to determine collision.

    //player1 collision: paddle right x pos is > ball x pos - diameter/2
    //&& ball y pos +- diameter/2 is in between paddle y pos and y pos - length
    if((ball.position.first - ball.diameter / 2.0 < 
        paddle[PLAYER_ONE].position.first + 
        paddle[PLAYER_ONE].dimensions.first) && 
       (ball.position.second + ball.diameter / 2.0 < 
        paddle[PLAYER_ONE].position.second) &&
       (ball.position.second - ball.diameter / 2.0 >
        paddle[PLAYER_ONE].position.second - 
        paddle[PLAYER_ONE].dimensions.second))
    {
        ball.velocity_vector.first *= -1;
        applySpin(ball, paddle[PLAYER_ONE]);
        return;
    }
    
    //player2 collision: paddle x pos  is < ball x pos + diameter/2
    //&& ball y pos +- diameter/2 is in between paddle y pos and y pos - length
    if((ball.position.first - ball.diameter / 2.0 > 
        paddle[PLAYER_TWO].position.first) &&
       (ball.position.second + ball.diameter / 2.0 < 
        paddle[PLAYER_TWO].position.second) &&
       (ball.position.second - ball.diameter / 2.0 >
        paddle[PLAYER_TWO].position.second -
        paddle[PLAYER_TWO].dimensions.second))
    {
        ball.velocity_vector.first *= -1;
        applySpin(ball, paddle[PLAYER_TWO]);
        return;
    }
    //apply appropriate vector change to ball based on where on the paddle
    //it collided.

    //determine if ball and wall collide.
    //apply appropriate vector change to ball if it hits a wall.
    //if ball y pos - diameter/2 is < bottom wall or ball y pos + diameter/2 
    //is > top wall.
}


 /***************************************************************************//**
 * movePaddle
 * Authors - Derek Stotz, Charles Parsons
 *
 * Checks currently pressed keys and moves a given paddle based on which keys
    are currently being pressed for a given player.
 ******************************************************************************/
void movePaddle(Paddle paddle, player mover)
{
    //after key-press move paddle in the direction indicated by the key pressed.
    //How does it know what key was pressed?
    //if player1 use 'w', 'a', 's', 'd' keys for paddle movement.
    //if player2 use 'up', 'down' ,'left', 'right' arrow keys for paddle 
    //movement.
    
}


 /***************************************************************************//**
 * applySpin
 * Authors - Derek Stotz, Charles Parsons
 *
 * Takes a ball and a colliding paddle and applies a "spin", or a velocity
    modification dependant on the paddle's relative position.
 ******************************************************************************/
void applySpin(Ball &ball, Paddle &paddle)
{
    int moving = 0; // 1 = up, -1 = down, 0 = not moving
    int spin = 0; //1 = top, -1 = bottom, 0 = middle
  
    //if paddle is moving up increase y velocity of ball.
    if(paddle.velocity_vector.second > 0)
    {
        moving = 1;
    }
    //if paddle is moving down increase -y velocity of ball.
    else if(paddle.velocity_vector.second < 0)
    {
        moving = -1;
    }
    //if paddle is moving toward ball increase -x velocity of ball.
    else
    {
        moving = 0;
    }
    
    //if ball hits top third of paddle make y velocity positive.
    if(ball.position.second > paddle.position.second -
       paddle.position.second / 3.0)
    {
        spin = 1;
    } 
    //if ball hits bottom third of paddle make y velocity negative.
    else if(ball.position.second < paddle.position.second -
            paddle.position.second * 2 / 3.0)
    {
        spin = -1;
    }
    ///if ball hits middle third of paddle do not change y velocity.
    else
    {
        spin = 0;
    }

    //formula for new ball velocity:
    //x_bvelocity = (xbvelocity > 0) ? -(x_bvelocity + x_pvelocity):
    //                                  
    //y bvelocity = 
}

/*Ball::Ball(int diam, int max_v, std::pair<int, int> v_vector, std::pair<int, int> pos, float* clr)
{
    this.diameter = diam;
    this.max_velocity = max_v;
    this.velocity_vector = v_vector;
    this.position = pos;
    this.color = clr;
}

Paddle::Paddle(std::pair<int, int> dim, std::pair<int, int> v_vector, std::pair<int, int> pos, std::pair<int, int> mov_speed, float* clr)
{
    this.dimensions = dim;
    this.velocity_vector = v_vector;
    this.position = pos;
    this.movement_speed = mov_speed;
    this.color = clr;
}

Menu::Menu(std::string* opt, int sel_index, fptr* opt_actions, float* bck_color, float* txt_color, float* sel_color)
{
    this.options = opt;
    this.selection_index = sel_index;
    this.option_actions = opt_actions;
    this.background_color = bck_color;
    this.text_color = txt_color;
    this.selection_color = sel_color
}*/
